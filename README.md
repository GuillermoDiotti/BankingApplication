# BankingApplication

Aplicación desarrollada como proyecto para la asignatura Diseño de Aplicaciones 1 junto con compañeros. La misma fue desarrollada con .net 6.0 y utiliza tecnologías como Blazor, C#

### Video de la demo
https://www.youtube.com/watch?v=SbgSIyy_-BY

#### Breve descripción del trabajo

En los inicios del proyecto, comenzamos a trabajar de manera conjunta en un mismo dispositivo mediante llamada, esto se debió a que consideramos buena opción dar los primeros pasos de una forma tal que fuese entendible para todos, y de esta manera dar el empujón inicial para posteriormente trabajar de manera más “individual”.
Dicha modalidad no quita el hecho de que, a medida de que cada integrante fuese avanzando con el presente proyecto, dictasemos nuevamente reunirnos mediante una llamada para ya sea, resolver conjuntamente algunos inconvenientes presentados, como para también  realizar una puesta a punto respecto al avance de cada uno.
El proyecto de construyó utilizando .NET 6.0 (utilizando C# como lenguaje de programación, MSTest para aplicar la metodología TDD, y Blazor para el frontend de la aplicación), Git y Github (siguiendo el modelo GitFlow).
Al comienzo del proyecto, tuvimos algunos inconvenientes a la hora de subir las ramas con las que estabamos trabajando localmente al repositorio remoto, específicamente, se estaba siguiendo GitFlow correctamente, pero las ramas que se mergeaban a la rama de desarrollo no aparecían remotamente. Esto fue solucionado rápidamente en versiones posteriores.


#### Breve descripción del Sistema:

La aplicación tiene un funcionamiento relativamente sencillo. Como comienzo, se consta de un portal donde el usuario es capaz de ingresar al sistema. Esto lo puede realizar tanto registrándose como nuevo usuario, como también, en el debido caso, iniciando sesión. Una vez dentro del sistema, la aplicación le genera al usuario activo un “espacio”, englobando toda la información bancaria pertinente del mismo. Estos “espacios” pueden ser compartidos con como tantas personas se quisiese. Por ejemplo, puedes tener, simultáneamente, un espacio compartido con “Pepe”, y otro con “Ana”. Logrando esto, se pueden compartir gastos, cuentas, y demás entre varios. Al hablar de las otras funcionalidades de la aplicación, el registro de cuentas es una de ella. Un usuario registrado en el sistema, es capaz de crear y administrar el número de cuentas que quiera. Dentro de la aplicación, se encuentran dos tipos de cuentas, las monetarias, como a su vez las cuentas destinadas a utilizarse a través de una tarjeta de crédito. Categorías, etiquetas utilizadas para categorizar los gastos. Pueden haber gategorías de ingreso como lo son los salarios, como egreso, pagar la factura de la luz. Por otro lado, se puede observar la sección del manejo de transacciones, entidades que hacen referencia a los movimientos del dinero. Al igual que las categorías, las transacciones se distribuyen en aquellas de tipo ingreso, y las de tipo costo. Otra funcionalidad presente en la aplicación, es la posibilidad de un usuario de crear objetivos para sus gastos, metas por así decirlo. Un objetivo muy común puede ser el de ahorrar. Finalizando, el sistema permite generar distintos reportes, contemplando toda la información dada de cierto usuario. Los reportes pueden ser de diversa índole, dandole un mayor énfasis en los aspectos que se busque.



#### Problemas enfrentados 

Al comienzo del obligatorio, como brevemente mencionado, al intentar aplicar lo dado en clase sobre la creación múltiples ramas para seguir las técnicas de GitFlow, cometimos un error. Nosotros creabamos la rama correspondiente a una feature, y luego, al finalizar las funcionalidades dentro de la respectiva rama, localmente, haciamos un merge hacia una rama llamada "dev". Una vez hecho esto, para finalizar, se hacia el pull al repositorio desde "dev". Esto resultó que en el historial de commits del repositorio en Github, no se pudieran ver estas ramas creadas para cada funcionalidad, solamente se podían visualizar las ramas "dev" y "main". Junto con la tutoría del ayudante de la materia, para poder resolver dicho suceso, tuvimos que aplicar otra técnica. Esta llamada técnica constó de, una vez completada todas las funcionalidades dentro de una rama feature, hacer un pull desde la misma, sin hacer previamente el merge. Al hacer esto, luego, realizamos un pull request en GitHub, solicitando la comprobación de otro integrante para así poder hacer el merge hacia dev. Esto solucionó la parte de la visualizacion de las distintas ramas creadas durante este proyecto. Más adelante, intentamos de hacer pull requests, pero a su vez tuvimos un inconveniente con ello. El problema fue que cuando intentamos fusionar un pull request previamente creado, este se fusionó con la rama main en vez de la rama dev. Buscamos de muchas maneras como intentar resolver el problema, hasta que creimos que encontramos la solución, la cual implementamos. Esta implementación constaba de realizar otro pull request que deshiciera los cambios generados por el pul request mal mergeado. Al parecer, esto empeoró más la situación, por lo que tuvimos que acudir al profesor de teórico que nos pudo ayudar a remediarlo. Por este suceso no nos sentíamos tan comodos realizando pull requests. El método o técnica final utilizada fue como una combinación de ambas. Localmente, volvimos a realizar el merge, solo que esta vez, en vez de subir el repositorio local a la nube desde la rama dev, comenzamos a hacerlo desde la rama de la propia funcionalidad. Esto sí generó que se pudieran observar las ramas funcionales en GitHub. 
Como consecuencia de esta cadena de inconvenientes generados, en GitHub
se puede notar que no se encuentran absolutamente todas las ramas de las features utilizadas, solo algunas de ellas.
Con una frecuencia algo alta, surgían algunos errores de compilación, o algunos errores dónde, a uno solo de los tres integrantes no le funcionaba el proyecto mientras que a los dos restantes sí, todos teniendo la misma versión. Estos, y algunos más, fueron problemas surgidos tomados con una menor importancia.
Cabe mencionar, que la técnica del desarrollo basado en TDD nos resultó como una barrera a un avance más agilizado. En momentos, veíamos que la utilización de esta técnica nos dificultaba para avanzar, haciendo que una funcionalidad algo sencilla demorase mucho tiempo a causa de la técnica mencionada. Como consecuencia de lo previamente dicho, en cierto momento, no nos quedó otro remedio que suspender de forma temporal la utilización de esta herramienta, para así poder sacar más provecho de los días restantes para avanzar con diversas funcionalidades. Aún así, más sobre el final, una vez consideramos tener un avance acorde comparándolo con el tiempo restante, retomamos con la utilización de esta técnica.
Por último a documentar, aunque probablemente no el último inconveniente, llegamos a tener dificultades con el navbar de la interfaz gráfica de blazor. Una vez encarada la sección de interfaz de usuario, nos cuestionamos sobre la utilidad del navbar preestablecido brindado por blazor, en tal punto que llegamos a eliminar todas las clases y demás asociadas a este del proyecto. Supusimos que no se iba a utilizar en lo absoluto, ya que creíamos que con simplemente implementar distintos botones para la navegación entre páginas bastaría. Esto cambió hasta que nos enfrentamos con el requerimiento de los llamados espacios. Establecimos allí que lo más conveniente sería implementar nuevamente el elemento navbar para así, cada usuario en su respectivo espacio, pueda navegar entre las diferentes secciones que ofrece la aplicación bancaria. Se documenta este suceso como un problema enfrentado ya que, al una vez decidir reinsertar todos los componentes tal cual estaban inicialmente, la aplicación se rompía y dejaba de compilar. Investigamos e investigamos, intentado crear un proyecto nuevo para poder cortar los elementos del navbar por defecto de este, pero aún así, nada. Tras su debido tiempo intentando solucionar esto, encontramos un repositorio público en GitHub de un desarrollador donde brindaba un navbar para una aplicación de blazor, por lo que decidimos basarnos en él. Dicho repositorio se puede acceder a través del siguiente enlace (https://github.com/martinmogusu/blazor-top-navbar)

#### Supuestos realizados

Como la consigna del proyecto resultó ser muy ambigua, nos vimos con la necesidad de realizar ciertos supuestos para facilitar el desarrollo de la aplicación
-Nombres de espacios dentro de un mismo usuario son unico:
Creimos conveniente que para evitar confusiones un usuario no pueda crear dos espacios con el mismo nombre. Sin embargo, si puede pertenecer a dos espacios con el mismo nombre, ya que estos espacios fueron creados por usuarios diferentes y limitar los nombres para un espacio entre distintos usuarios seria una medida muy restrictiva.
-Nombres unicos para las categorias:
 Es decir, que en un mismo espacio, no puedan haber más de una categoría con el mismo nombre. 
-Implementacion de IDs para transacciones:
El agregado de una etiqueta de identificación en la clase de transacción fue otro, logrando así poder identificar cada una de las instancias de este objeto.
-Implementacion de nombre a las tarjetas:
Creímos conveniente que para poder identificar mas facil cada tarjeta seria util que las tarjetas tambien tuvieran un nombre, ya que solo con los digitos o el banco emisor podian haber confusiones.
-Las cuentas tendrian un nombre unico:
A modo de evitar confusion a la hora de que un usuario eligiera una tarjeta/cuenta para realizar determianada accion decidimos que las mismas contarian con un nombre unico.
-Transacciones en USD:
Como forma de estandarizar las transacciones en dolares decidimos que estas solo se puedan realizar si existe un tipo de cambio/cotizacion del dolar para la fecha en la que se quiere realizar la transaccion. Lo mismo aplicaria si tengo una cuenta en USD pero quiero realizar una transaccion en UYU, en este caso la aplicación tambien va indicar que primero se debe de definir el tipo de cambio para la fecha.
-Edicion/eliminacion de categorias:
Con el objetivo de evitar confusiones y tratar de mantener mas el orden, decidimos que no se podrian editar o eliminar categorias si ya tienen transacciones o objetivos asociados.
-Edicion/eliminacion de cuentas:
Como mencionado en el punto anterior, creímos logico tratar del mismo modo a las cuentas, por que lo que no se podran editar o eliminar cuentas con transacciónes asociadas.
-Edicion/Eliminacion de tipos de cambios
Para llevar un control coherente de las transacciones, decidimos que no se puedan editar/eliminar tipos de cambios si existe una transaccion que dependa del mismo.



#### Bugs, Funcionalidades no implementadas, y Cambios a futuro

Un cambio que con mas tiempo nos hubiera gustado realizar seria la eliminacion de todas las listas que almacena el usuario. Como equipo implementamos la funcionalidad de los espacios al final, y para ese entonces ya cada usuario guardaba su propia lista de categorias, cuentas, etc, pero al momento de crear los espacios nos dimos cuenta que era posible prescindir de esto, y que hubiera sido suficiente almacenar esa informacion unicamente en los espacios, ya que actualmente hay ciertos datos repetidos.	

#### Decisiones de diseño

Una de las decisiones de diseño tomadas se basó en las implementación de la clase espacio. En este proyecto, esta fue implementada registrando cada transacción, cuenta, categoría, registro, etc, en listas, una para cada objeto. En un momento, consideramos, en vez de estructurar de esta forma la clase espacio, no realizarla conteniendo todas estas listas, y poner como parámetro a cada método de agregar (de transacción, cuenta, etc) un objeto de tipo espacio. Esta decisión se resolvió implementando la clase con las listas de cada objeto, lo vimos de una manera con mayor facilidad, ya que al intentar de llegar a hacerlo de la otra manera, muchos cambios tendríamos que hacer. 
Otra decision que tomamos fue la utilizacion de una clase abstracta para la implementacion de los distintos tipos de cuentas, hacer esto nos permitio reducir la cantidad de codigo repetido pudiendo definir solo una clase de LogicaCuenta que sirviera para ambas subclases, asi como tambien almacenar ambas subclases en una sola lista de cuentas, ademas de esto habian ciertos atributos en comun que ambas sublcases compartian por lo que una clase padre (cuenta) con dichos atributos era resultaba muy util. La diferencia en este caso con utilizar una herencia normal fue que nunca ibamos a instanciar un cuenta por si sola, ya que en realidad solo existian cuentas monetarias o tarjetas de credito.
Decidimos tambien implementar una clase abstracta en Reporte, esto fue debido a que la clase reporte en si nunca iba a ser instanciada, en cambio nos interesaba instanciar las clases hijas de reporte, que eran tipos mas especificos de reportes, esto a la vez permitio ahorrarnos la creacion de distintas clases de Logica y poder controlar todos los reportes desde LogicaReporte.
Para resumir, el uso de las clases abstractas fue un recurso esencial que nos facilito el uso del polimorfismo y de esta manera pudimos tratas a distintos objetos como si fueran de la misma clase ya que estos heredaban de la superclase, esto nos permitio ahorrar una gran cantidad de codigo ya que pudimos escribir codigo generico que funcionara con objetos de ambas clases sin saber de antemano la clase especifica de cada objeto.
Otro punto importante de diseño a considerar es el uso de la encapsulacion, la mayoria de las clases tenian atributos o metodos que decidimos que era mejor que fueran privados, lo pensamos de esta manera para evitar que fueran accesibles fuera de la clase y siguiendo el principio de clean code comenzaban con minuscula y tenian nombres descriptivos, estos eran principalmente utilizados como funciones auxiliares o variables auxiliares dentro de una clase. Ademas de esto, los "setters" no solo establecían valores en los atributos, sino que también incluían lógica de validación para asegurarse de que los datos ingresados fueran coherentes y válidos. Por ejemplo, podiamos comprobar que un mail o contraseña ingresado por el usuario fueran validas. La encapsulación también contribuyó a la abstracción al ocultar los detalles internos de la implementación de una clase y proporcionar una interfaz más abstracta para interactuar con ella. Esto simplificó el uso de las clases y permitió cambios internos en la implementación sin afectar el código que las utiliza.
Para almacenar los distintos usuarios decidimos utilizar un repositorio, luego los objetos espacio y usuario almacenan toda la informacion correspondiente a ellos mismos, es decir cada usuario y espacio tiene una lista de sus categorias, de sus cuentas, de sus transacciones, de sus objetivos y sus tipos de cambio.
Otra decision de diseño que tomamos fue a la hora de manejar los distintos errores y excepciones que podian surgir, para esto decidimos que lo mejor era crear dos clases de excepciones personalizadas, una clase que represente las excepciones de tipo logica, y la otra de tipo dominio. Ya habiendo creado estas clases utilizamos un try and catch en cada campo que el usuario podia interactuar, dentro del try colocamos el codigo para un escenario ideal y dentro del catch en caso de un comportamiento equivocado, creamos una excepcion del tipo correspondiente y mostramos el mensaje por pantalla que indica el error claramente.
El proximo punto importante a explicar es como es nuestro caso interacuta la interfaz con el dominio, para esto hubo siempre dos pasos iniciales, el primero era agregar en la seccion de “Program” la linea “builder.Services.AddSingleton<ClaseAUtilizar>();” y luego en la pagina de la interfaz un “@inject ClaseAUtilizar” estos pasos eran esenciales para vincular nuestro codigo con la interfaz. Luego de eso, mediante el uso de inputs en Razor era como el usuario podia interactuar con el dominio, el usuario inserta los datos deseados para realizar una accion y la logica de nuestra aplicacion se encarga de validarlos, en caso de que los datos sean correctos se le notifica al usuario y esto tiene un efecto directo en el domino, ya sea creando una nueva cuenta o categoria, etc, en caso de que los datos ingresados no sean validos el sistema captura la excepcion y le informa al usuario de que ha habido un error.
Cabe mencionar que tratamos de implementar lo mejor que pudimos el clean code en la mayoria de los aspectos, para esto tratamos de utilizar nombres descriptivos para las clases, métodos y variables, lo que facilita la comprensión del código. Los nombres indicaban claramente el propósito y la función de cada elemento; Tratamos en la mayoria de los casos de dividir las funciones en fragmentos más pequeños y manejables, creando funciones auxiliares. Cada función  tratamos de que realizara una tarea específica y que tuviera un único propósito, lo que mejoraba la claridad del código.
Finalmente para el manejo de los directorios y archivos de la interfaz en nuestro proyecto, decidimos crear un proyecto llamado “InterfazUsuario”.  Dentro de este paquete decidimos que lo mejor para mantener el orden era tener cada seccion de la pagina en una carpeta por separado con un nombre descriptivo, por ejemplo todo lo relacionado a Categorias se encontraba en una carpeta “Categorias” y asi con cada archivo, para definir la url de los mismos partiamos de lo mas basico, siendo esto el nombre de la seccion por ejemplo “/Categoria” y a medida de que el usuario iba entrando mas a fondo en dicha seccion, esto se iba viendo representado en la url, por ejemplo “/Categoria/Editar{NombreDeLaCategoria}”.


#### Estructura del proyecto

Desde aspectos generales, este proyecto se estructuró en 6 paquetes. Uno de ellos es “Dominio”, conservando la definición de las clases con sus respectivos atributos. En estas clase se evitó implementar funcionalidades, para así mantener una línea divisora entre las clases de dominio y las funcionalidades de estas. Este mencionado paquete conteniendo las funcionalidades es “Lógica”, habiendo una clase dentro de este para cada clase de dominio, excepto para las clases de dominio de tipo abstracto, allí se tomó como referencia a su clase padre. A su vez, se presentan 2 paquetes destinados al testeo, uno por el lado del testeo del paquete Dominio, y otro del paquete Logica. En ellos se validan los correctos funcionamientos de las operaciones utilizadas. Al paquete restante se lo conservó para la parte del front-end de la aplicación

#### Justificacion del UML:

Los diagramas de paquetes y clases correspondientes se pueden visualizar sobre el final del documento, entrenos anexos 1 al 12.
Cabe agregar, que para “capturar” toda la información y todos los datos, creamos una nueva clase llamada “UserMemoryRepository”, siendo esta una clase que hereda de una clase de tipo interfaz, y tiene redefinidos cada uno de los métodos de esta última. El motivo de la implementación de la clase de tipo interfaz, se debe a que, al ser de tipo interfaz, define un modelo y estructura al definir métodos básicos que sus clases hijas deben implementar en su totalidad. Estos constan de agregar elementos a una lista, buscar cierto elemento en una lista que cumpla con una condición dada, la obtención de todos los datos de la hablada lista, actualizar cierto objeto ya presente en la lista al entregarle a la función los campos a actualizar, y por último el método de eliminar objetos de la lista.
Consiguientemente, al hablar de las clases de “Cuenta” y “Reporte”, como ya previamente mencionado, su implementacion constó de ser de tipo abstractas, teniendo cada una de ellas dos clases hijas. La particularidad de las clases de tipo abstractas, es que no se pueden crear instancias de ellas, por lo que tomamos eso como beneficio, ya que, al hablar por ejemplo de la clase “Cuenta”, simplemente realizabamos las instancias de sus clases hijas, señalándole a estas ser de tipo de la clase padre. Dichas instancias se realizaron siguiendo el formato de “Case padre = new clase hija()”. Esto facilitó que a la hora de controlar una lista con todas las cuentas, ya que sse pasó de necesitar una lista por cada clase hija de Cuenta, a simplemente una lista con toda la información pertinente, siendo esta de tipo Cuenta, y vinculándo distintos objetos.
Por último, respetamos lo dado en el curso, en el que la unica relacion entre paquetes es la de dependencia.
Por el lado de aclaraciones respecto al diagrama de paquetes y clases, se debe mencionar que aquellas clases con formato de texto itálica son abstractas, y que, como bien lo dictó el profesor de teórico del cursos a nuestro equipo personalmente, los métodos los cuales son sobreescritos (tienen un override), se visualizan en el diagrama de igual forma que los métodos convencionales restantes. 

#### Detalle de cobertura de pruebas unitarias

Gracias a la metodología TDD, pudimos alcanzar un indice de cobertura para las clases solicitadas mayor al 90% sin mayores dificultades. Para crear una nueva clase, hicimos primero su respectiva clase de prueba donde se testean las funcionalidades de la misma; en primer lugar, creamos el test correspondiente de manera que, con la funcionalidad implementada, dé el resultado esperado, posteriormente, creamos dicha función en la clase que se está desarrollando con el mínimo código posible para que funcione, y luego aplicamos refactor para mejorar el código sin cambiar su funcionalidad. De esta manera, nos evitamos varios resultados no deseados, al mismo tiempo que obtenemos cobertura para la clase. Finalmente, se tuvo que implementar algunos test extra para superar el índice mínimo de cobertura requerido.
Para algunos métodos específicos que eran más complejos de testear, se tuvo que implementar Mocks para llegar a la cobertura deseada.


#### Anexos

Para evitar confusiones y mareos, se decidió realizar los diagramas separándolos en base a lo que se quiera mostrar. Estos se dividen en el diagrama de paquetes, y el diagrama de clases, el cual se subdivide en todas aquellas clases pertenecientes al paquete de Logica.

##### Diagrama de Paquetes
<img width="700" alt="Captura de pantalla 2024-10-30 a la(s) 20 03 08" src="https://github.com/user-attachments/assets/0ee2631d-e154-4846-a5d3-a04533edd9c5">

##### Cobertura de las clases

###### Logica
<img width="614" alt="Captura de pantalla 2024-10-30 a la(s) 20 08 13" src="https://github.com/user-attachments/assets/65828599-78e7-4eda-abc6-9e4b30406423">

###### Dominio
<img width="599" alt="Captura de pantalla 2024-10-30 a la(s) 20 08 22" src="https://github.com/user-attachments/assets/4729c738-9511-499a-97a5-2841e5ffb6c6">

###### Repositorio
<img width="600" alt="Captura de pantalla 2024-10-30 a la(s) 20 09 11" src="https://github.com/user-attachments/assets/00a2d862-4fc5-4d8c-b3ee-b6b91ecea90b">
